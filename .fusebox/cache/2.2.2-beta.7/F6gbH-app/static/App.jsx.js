module.exports = { contents: "\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar React = require(\"react\");\r\n// var data = require(\"../assets/data/data.json\"); //easy way to load in data\r\nvar d3 = require(\"d3\"); //typescript uses this to import, instead of the usual import d3 from 'd3'\r\nvar store = require(\"store\");\r\nvar constants_1 = require(\"./constants\");\r\nvar constants_2 = require(\"./constants\");\r\nvar Neuron_1 = require(\"./Neuron\");\r\nvar Controls_1 = require(\"./Controls\");\r\nvar plotSetup = function (data, svgWidth, svgHeight) {\r\n    if (svgWidth === void 0) { svgWidth = 1000; }\r\n    if (svgHeight === void 0) { svgHeight = 1000; }\r\n    var xs = data.map(function (row) { return +row.pos[0]; }); //create an array of x positions\r\n    var ys = data.map(function (row) { return +row.pos[1]; });\r\n    var xRange = d3.extent(xs); // min, max\r\n    var yRange = d3.extent(ys);\r\n    var xScale = d3\r\n        .scaleLinear()\r\n        .domain(xRange)\r\n        .range([0 + constants_1.svgPadding, svgWidth - constants_1.svgPadding]); //convert raw x position data into pixel space\r\n    var yScale = d3\r\n        .scaleLinear()\r\n        .domain(yRange)\r\n        .range([0 + constants_1.svgPadding, svgHeight - constants_1.svgPadding]);\r\n    var pos = xs.map(function (x, i) {\r\n        //position array to loop over and create a circle for each point\r\n        return [xScale(x), yScale(ys[i])];\r\n    });\r\n    return { xs: xs, ys: ys, xRange: xRange, yRange: yRange, xScale: xScale, yScale: yScale, pos: pos, svgWidth: svgWidth, svgHeight: svgHeight };\r\n};\r\n//the <any, any> is a typescript thing. It let's us define the allowed/required props (things passed into it), and the state\r\nvar App = (function (_super) {\r\n    __extends(App, _super);\r\n    function App() {\r\n        var _this = _super.call(this) || this;\r\n        _this.startTimer = function () {\r\n            //d3.interval fires every 35ms\r\n            _this.timer = d3.interval(function (elapsed) {\r\n                //save to this.timer so we can use this.timer.stop()\r\n                if (_this.state.time < _this.state.data[0].spikes.length)\r\n                    _this.setState({ time: _this.state.time + 1 }); //increment time this way so react will rerender on change\r\n            }, 35);\r\n        };\r\n        _this.pauseTimer = function () {\r\n            _this.timer.stop();\r\n            _this.setState({ isPlaying: false });\r\n        };\r\n        _this.toggleTimer = function () {\r\n            if (_this.state.isPlaying) {\r\n                _this.pauseTimer();\r\n            }\r\n            else {\r\n                _this.startTimer();\r\n            }\r\n            _this.setState({ isPlaying: !_this.state.isPlaying });\r\n        };\r\n        _this.setTime = function (value) {\r\n            _this.setState({ time: value });\r\n        };\r\n        _this.state = {\r\n            //only change with this.setState({var: newValue})\r\n            time: 0,\r\n            isPlaying: false,\r\n            data: [],\r\n            plotMeta: {}\r\n        };\r\n        return _this;\r\n    }\r\n    App.prototype.componentWillMount = function () {\r\n        var _this = this;\r\n        var savedtime = store.get(\"time\") || 0;\r\n        this.setState({ time: savedtime });\r\n        fetch(\"../assets/data/data.json\").then(function (res) { return res.json(); }).then(function (data) {\r\n            _this.setState({ data: data });\r\n            var plotMeta = plotSetup(data, constants_2.svgWidth, constants_2.svgHeight);\r\n            _this.setState({ plotMeta: plotMeta });\r\n        });\r\n    };\r\n    App.prototype.componentDidUpdate = function () {\r\n        store.set(\"time\", this.state.time);\r\n    };\r\n    App.prototype.render = function () {\r\n        var _this = this;\r\n        var _a = this.state.plotMeta, svgWidth = _a.svgWidth, svgHeight = _a.svgHeight, pos = _a.pos;\r\n        var data = this.state.data;\r\n        if (!svgWidth || !svgHeight || !pos)\r\n            return React.createElement(\"div\", null, \"loading\");\r\n        //render is a react specific function from React.Component.\r\n        return (\r\n        // the parens after return are important. also need to wrap all this html-like code in one element. a div in this case, as usual.\r\n        //the bellow code is jsx which is html tags that work in js. if you want to use variables, functions, or standard js from above put it in {}\r\n        React.createElement(\"div\", null,\r\n            React.createElement(\"div\", null,\r\n                React.createElement(\"svg\", { width: \"100%\", height: \"100%\", style: { maxHeight: '80vh' }, viewBox: \"0,0, \" + svgWidth + \", \" + svgHeight }, pos.map(function (xy, i) {\r\n                    //note this pos.map begings and ends with {}\r\n                    //.map is how we loop over arrays. in this case, we return a circle for each posisiton.\r\n                    var isSpiking = +data[i].spikes[_this.state.time] === 1; //data has all the cells, each with {label, spikes, pos} fields\r\n                    return (\r\n                    //these parens are important in react\r\n                    React.createElement(Neuron_1.default, { key: i, cx: xy[0], cy: xy[1], r: isSpiking ? constants_2.neuronRadius.active : constants_2.neuronRadius.inActive, name: data[i].label, active: isSpiking }));\r\n                })),\r\n                React.createElement(Controls_1.Controls, { time: this.state.time, togglePlay: this.toggleTimer, changeTime: this.setTime, isPlaying: this.state.isPlaying }))));\r\n    };\r\n    return App;\r\n}(React.Component));\r\nexports.App = App;\r\n//# sourceMappingURL=App.js.map",
dependencies: ["react","d3","store","./constants","./constants","./Neuron","./Controls"],
sourceMap: "{\"version\":3,\"file\":\"App.jsx\",\"sourceRoot\":\"\",\"sources\":[\"/src/App.tsx\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"import * as React from \\\"react\\\";\\r\\n// var data = require(\\\"../assets/data/data.json\\\"); //easy way to load in data\\r\\nimport * as d3 from \\\"d3\\\"; //typescript uses this to import, instead of the usual import d3 from 'd3'\\r\\nimport * as _ from \\\"lodash\\\";\\r\\nimport styled from \\\"styled-components\\\";\\r\\nvar store = require(\\\"store\\\");\\r\\nimport { svgPadding as pad } from \\\"./constants\\\";\\r\\nimport { neuronRadius, svgWidth, svgHeight } from \\\"./constants\\\";\\r\\n\\r\\nimport Neuron from \\\"./Neuron\\\";\\r\\nimport {Controls} from \\\"./Controls\\\";\\r\\n\\r\\nconst plotSetup = (data, svgWidth = 1000, svgHeight = 1000) => {\\r\\n  const xs: number[] = data.map(row => +row.pos[0]); //create an array of x positions\\r\\n  const ys: number[] = data.map(row => +row.pos[1]);\\r\\n  const xRange: number[] = d3.extent(xs); // min, max\\r\\n  const yRange: number[] = d3.extent(ys);\\r\\n  const xScale = d3\\r\\n    .scaleLinear()\\r\\n    .domain(xRange)\\r\\n    .range([0 + pad, svgWidth - pad]); //convert raw x position data into pixel space\\r\\n  const yScale = d3\\r\\n    .scaleLinear()\\r\\n    .domain(yRange)\\r\\n    .range([0 + pad, svgHeight - pad]);\\r\\n  const pos = xs.map((x, i) => {\\r\\n    //position array to loop over and create a circle for each point\\r\\n    return [xScale(x), yScale(ys[i])];\\r\\n  });\\r\\n\\r\\n  return { xs, ys, xRange, yRange, xScale, yScale, pos, svgWidth, svgHeight };\\r\\n};\\r\\n\\r\\n//the <any, any> is a typescript thing. It let's us define the allowed/required props (things passed into it), and the state\\r\\nexport class App extends React.Component<any, any> {\\r\\n  //init class variables\\r\\n  stopId;\\r\\n  timer;\\r\\n\\r\\n  constructor() {\\r\\n    super();\\r\\n    this.state = {\\r\\n      //only change with this.setState({var: newValue})\\r\\n      time: 0,\\r\\n      isPlaying: false,\\r\\n      data: [],\\r\\n      plotMeta: {}\\r\\n    };\\r\\n  }\\r\\n  componentWillMount() {\\r\\n    const savedtime = store.get(\\\"time\\\") || 0;\\r\\n    this.setState({ time: savedtime });\\r\\n\\r\\n    fetch(\\\"../assets/data/data.json\\\").then(res => res.json()).then(data => {\\r\\n      this.setState({ data });\\r\\n      const plotMeta = plotSetup(data, svgWidth, svgHeight);\\r\\n      this.setState({ plotMeta });\\r\\n    });\\r\\n  }\\r\\n\\r\\n  componentDidUpdate() {\\r\\n    store.set(\\\"time\\\", this.state.time);\\r\\n  }\\r\\n\\r\\n  startTimer = () => {\\r\\n    //d3.interval fires every 35ms\\r\\n    this.timer = d3.interval(elapsed => {\\r\\n      //save to this.timer so we can use this.timer.stop()\\r\\n      if (this.state.time < this.state.data[0].spikes.length)\\r\\n        this.setState({ time: this.state.time + 1 }); //increment time this way so react will rerender on change\\r\\n    }, 35);\\r\\n  };\\r\\n\\r\\n  pauseTimer = () => {\\r\\n    this.timer.stop();\\r\\n    this.setState({ isPlaying: false });\\r\\n  };\\r\\n\\r\\n  toggleTimer = () => {\\r\\n    if (this.state.isPlaying) {\\r\\n      this.pauseTimer();\\r\\n    } else {\\r\\n      this.startTimer();\\r\\n    }\\r\\n    this.setState({ isPlaying: !this.state.isPlaying });\\r\\n  };\\r\\n  setTime = value => {\\r\\n    this.setState({ time: value });\\r\\n  };\\r\\n\\r\\n  render() {\\r\\n    const { svgWidth, svgHeight, pos } = this.state.plotMeta;\\r\\n    const { data } = this.state;\\r\\n    if (!svgWidth || !svgHeight || !pos) return <div>loading</div>;\\r\\n    //render is a react specific function from React.Component.\\r\\n    return (\\r\\n      // the parens after return are important. also need to wrap all this html-like code in one element. a div in this case, as usual.\\r\\n      //the bellow code is jsx which is html tags that work in js. if you want to use variables, functions, or standard js from above put it in {}\\r\\n      <div>\\r\\n        <div>\\r\\n          <svg\\r\\n            width={\\\"100%\\\" }\\r\\n            height={\\\"100%\\\"}\\r\\n            style={{maxHeight: '80vh'}}\\r\\n            viewBox={`0,0, ${svgWidth}, ${svgHeight}`}\\r\\n          >\\r\\n            {pos.map((xy, i) => {\\r\\n              //note this pos.map begings and ends with {}\\r\\n              //.map is how we loop over arrays. in this case, we return a circle for each posisiton.\\r\\n              const isSpiking = +data[i].spikes[this.state.time] === 1; //data has all the cells, each with {label, spikes, pos} fields\\r\\n              return (\\r\\n                //these parens are important in react\\r\\n                <Neuron\\r\\n                  key={i}\\r\\n                  cx={xy[0]}\\r\\n                  cy={xy[1]}\\r\\n                  r={isSpiking ? neuronRadius.active : neuronRadius.inActive} // this ? : business is called a ternary operator. means if isspiking is true return 20 else return 5\\r\\n                  name={data[i].label}\\r\\n                  active={isSpiking}\\r\\n                />\\r\\n              );\\r\\n            })}\\r\\n          </svg>\\r\\n           <Controls\\r\\n            time={this.state.time}\\r\\n            togglePlay={this.toggleTimer}\\r\\n            changeTime={this.setTime}\\r\\n            isPlaying={this.state.isPlaying}\\r\\n          /> \\r\\n        </div>\\r\\n      </div>\\r\\n    );\\r\\n  }\\r\\n}\\r\\n\"]}",
headerContent: undefined,
mtime: 1501827289495,
devLibsRequired : undefined
};