module.exports = { contents: "\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar React = require(\"react\");\r\n// var data = require(\"../assets/data/data.json\"); //easy way to load in data\r\nvar d3 = require(\"d3\"); //typescript uses this to import, instead of the usual import d3 from 'd3'\r\nvar _ = require(\"lodash\");\r\nvar store = require(\"store\");\r\nvar constants_1 = require(\"./constants\");\r\nvar constants_2 = require(\"./constants\");\r\nvar Controls_1 = require(\"./Controls\");\r\nvar plotSetup = function (data, svgWidth, svgHeight) {\r\n    if (svgWidth === void 0) { svgWidth = 1000; }\r\n    if (svgHeight === void 0) { svgHeight = 1000; }\r\n    var xs = data.map(function (row) { return +row.pos[0]; }); //create an array of x positions\r\n    var ys = data.map(function (row) { return +row.pos[1]; });\r\n    var xRange = d3.extent(xs); // min, max\r\n    var yRange = d3.extent(ys);\r\n    var xScale = d3\r\n        .scaleLinear()\r\n        .domain(xRange)\r\n        .range([0 + constants_1.svgPadding, svgWidth - constants_1.svgPadding]); //convert raw x position data into pixel space\r\n    var yScale = d3\r\n        .scaleLinear()\r\n        .domain(yRange)\r\n        .range([0 + constants_1.svgPadding, svgHeight - constants_1.svgPadding]);\r\n    var pos = xs.map(function (x, i) {\r\n        //position array to loop over and create a circle for each point\r\n        return [xScale(x), yScale(ys[i])];\r\n    });\r\n    return { xs: xs, ys: ys, xRange: xRange, yRange: yRange, xScale: xScale, yScale: yScale, pos: pos, svgWidth: svgWidth, svgHeight: svgHeight };\r\n};\r\n//the <any, any> is a typescript thing. It let's us define the allowed/required props (things passed into it), and the state\r\nvar App = (function (_super) {\r\n    __extends(App, _super);\r\n    function App() {\r\n        var _this = _super.call(this) || this;\r\n        _this.startTimer = function () {\r\n            //d3.interval fires every 35ms\r\n            _this.timer = d3.interval(function (elapsed) {\r\n                //save to this.timer so we can use this.timer.stop()\r\n                if (_this.state.time < _this.state.data[0].spikes.length)\r\n                    _this.setState({ time: _this.state.time + 1 }); //increment time this way so react will rerender on change\r\n                _this.activationLocations(_this.state.propagation, _this.state.time);\r\n            }, 15);\r\n        };\r\n        _this.pauseTimer = function () {\r\n            _this.timer.stop();\r\n            _this.setState({ isPlaying: false });\r\n        };\r\n        _this.toggleTimer = function () {\r\n            if (_this.state.isPlaying) {\r\n                _this.pauseTimer();\r\n            }\r\n            else {\r\n                _this.startTimer();\r\n            }\r\n            _this.setState({ isPlaying: !_this.state.isPlaying });\r\n        };\r\n        _this.setTime = function (value) {\r\n            _this.setState({ time: value });\r\n        };\r\n        _this.state = {\r\n            //only change with this.setState({var: newValue})\r\n            time: 0,\r\n            isPlaying: false,\r\n            data: [],\r\n            plotMeta: {},\r\n            links: [],\r\n            propagation: [],\r\n            propagationsOnScreen: []\r\n        };\r\n        return _this;\r\n    }\r\n    App.prototype.componentWillMount = function () {\r\n        var _this = this;\r\n        var savedtime = store.get(\"time\") || 0;\r\n        this.setState({ time: savedtime });\r\n        Promise.all([\r\n            fetch(\"../assets/data/data.json\").then(function (res) { return res.json(); }),\r\n            fetch(\"../assets/data/links.json\").then(function (res) { return res.json(); }),\r\n            fetch(\"../assets/data/propagation.json\").then(function (res) { return res.json(); })\r\n        ]).then(function (json) {\r\n            var data = json[0];\r\n            var links = json[1];\r\n            var propagation = json[2];\r\n            _this.setState({ propagation: propagation });\r\n            _this.setState({ data: data });\r\n            var _a = plotSetup(data, constants_2.svgWidth, constants_2.svgHeight), xScale = _a.xScale, yScale = _a.yScale, plotMeta = __rest(_a, [\"xScale\", \"yScale\"]);\r\n            _this.xScale = xScale;\r\n            _this.yScale = yScale;\r\n            _this.setState({ plotMeta: plotMeta });\r\n            var scaledLinks = links.map(function (link) {\r\n                var sx = _this.xScale(link.sourcePos[0]);\r\n                var sy = _this.yScale(link.sourcePos[1]);\r\n                var tx = _this.xScale(link.targetPos[0]);\r\n                var ty = _this.yScale(link.targetPos[1]);\r\n                return { sx: sx, sy: sy, tx: tx, ty: ty };\r\n            });\r\n            _this.setState({ links: scaledLinks });\r\n        });\r\n    };\r\n    App.prototype.componentDidUpdate = function () {\r\n        store.set(\"time\", this.state.time);\r\n    };\r\n    App.prototype.activationLocations = function (propagation, time) {\r\n        var _this = this;\r\n        if (!propagation || !time)\r\n            return;\r\n        //when time is zero\r\n        var propagationsStarting = propagation[time] || []; //starting activations\r\n        var propagationsContinuing = this.state.propagationsOnScreen.filter(function (p) {\r\n            return _.get(p, 'targetActivationTime', 0) >= time;\r\n        });\r\n        var propagationsOnScreen = _.concat(propagationsStarting, propagationsContinuing);\r\n        propagationsOnScreen.forEach(function (p, i) {\r\n            var progress = (time - p.sourceActivationTime) / p.timeDiff;\r\n            var pos = d3.interpolateObject(p.sourcePos, p.targetPos)(progress);\r\n            propagationsOnScreen[i].interpPos = [_this.xScale(+pos[0]), _this.yScale(+pos[1])];\r\n        });\r\n        console.log('debug', propagationsStarting, propagationsContinuing, propagationsOnScreen);\r\n        this.setState({ propagationsOnScreen: propagationsOnScreen });\r\n    };\r\n    App.prototype.render = function () {\r\n        var _this = this;\r\n        var _a = this.state.plotMeta, svgWidth = _a.svgWidth, svgHeight = _a.svgHeight, pos = _a.pos;\r\n        var _b = this.state, data = _b.data, links = _b.links, propagation = _b.propagation, time = _b.time, propagationsOnScreen = _b.propagationsOnScreen;\r\n        if (!svgWidth || !svgHeight || !pos || !propagation)\r\n            return React.createElement(\"div\", null, \"loading\");\r\n        //render is a react specific function from React.Component.\r\n        return (\r\n        // the parens after return are important. also need to wrap all this html-like code in one element. a div in this case, as usual.\r\n        //the bellow code is jsx which is html tags that work in js. if you want to use variables, functions, or standard js from above put it in {}\r\n        React.createElement(\"div\", null,\r\n            React.createElement(\"div\", null,\r\n                React.createElement(\"svg\", { width: \"100%\", height: \"100%\", style: { maxHeight: \"80vh\" }, viewBox: \"0,0, \" + svgWidth + \", \" + svgHeight },\r\n                    links.map(function (link, i) {\r\n                        var sx = link.sx, sy = link.sy, tx = link.tx, ty = link.ty;\r\n                        return (React.createElement(\"line\", { key: i, x1: sx, y1: sy, x2: tx, y2: ty, stroke: constants_2.colors.connector, style: { opacity: constants_2.linkOpacity } }));\r\n                    }),\r\n                    propagationsOnScreen.map(function (p, i) {\r\n                        return (React.createElement(\"circle\", { key: p.id, cx: p.interpPos[0], cy: p.interpPos[1], r: 8, fill: p.sourceType === 'excites' ? constants_2.colors.excitesPropagation : constants_2.colors.inhibitsPropagation }));\r\n                    }),\r\n                    pos.map(function (xy, i) {\r\n                        //note this pos.map begings and ends with {}\r\n                        //.map is how we loop over arrays. in this case, we return a circle for each posisiton.\r\n                        var isSpiking = +data[i].spikes[_this.state.time] === 1; //data has all the cells, each with {label, spikes, pos} fields\r\n                        var activeColor = data[i].type === 'excites' ? constants_2.colors.excitesActive : constants_2.colors.inhibitsActive;\r\n                        var inActiveColor = data[i].type === 'excites' ? constants_2.colors.excitesInActive : constants_2.colors.inhibitsInActive;\r\n                        return (\r\n                        //these parens are important in react\r\n                        React.createElement(\"circle\", { key: i, cx: xy[0], cy: xy[1], r: isSpiking ? constants_2.neuronRadius.active : constants_2.neuronRadius.inActive, name: data[i].label, fill: isSpiking ? activeColor : inActiveColor }));\r\n                    })),\r\n                React.createElement(Controls_1.Controls, { time: this.state.time, togglePlay: this.toggleTimer, changeTime: this.setTime, isPlaying: this.state.isPlaying }))));\r\n    };\r\n    return App;\r\n}(React.Component));\r\nexports.App = App;\r\n//# sourceMappingURL=App.js.map",
dependencies: ["react","d3","lodash","store","./constants","./constants","./Controls"],
sourceMap: "{\"version\":3,\"file\":\"App.jsx\",\"sourceRoot\":\"\",\"sources\":[\"/src/App.tsx\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"import * as React from \\\"react\\\";\\r\\n// var data = require(\\\"../assets/data/data.json\\\"); //easy way to load in data\\r\\nimport * as d3 from \\\"d3\\\"; //typescript uses this to import, instead of the usual import d3 from 'd3'\\r\\nimport * as _ from \\\"lodash\\\";\\r\\nimport styled from \\\"styled-components\\\";\\r\\nvar store = require(\\\"store\\\");\\r\\nimport { svgPadding as pad } from \\\"./constants\\\";\\r\\nimport {\\r\\n  neuronRadius,\\r\\n  svgWidth,\\r\\n  svgHeight,\\r\\n  colors,\\r\\n  linkOpacity\\r\\n} from \\\"./constants\\\";\\r\\nimport { Controls } from \\\"./Controls\\\";\\r\\n\\r\\nconst plotSetup = (data, svgWidth = 1000, svgHeight = 1000) => {\\r\\n  const xs: number[] = data.map(row => +row.pos[0]); //create an array of x positions\\r\\n  const ys: number[] = data.map(row => +row.pos[1]);\\r\\n  const xRange: number[] = d3.extent(xs); // min, max\\r\\n  const yRange: number[] = d3.extent(ys);\\r\\n  const xScale = d3\\r\\n    .scaleLinear()\\r\\n    .domain(xRange)\\r\\n    .range([0 + pad, svgWidth - pad]); //convert raw x position data into pixel space\\r\\n  const yScale = d3\\r\\n    .scaleLinear()\\r\\n    .domain(yRange)\\r\\n    .range([0 + pad, svgHeight - pad]);\\r\\n  const pos = xs.map((x, i) => {\\r\\n    //position array to loop over and create a circle for each point\\r\\n    return [xScale(x), yScale(ys[i])];\\r\\n  });\\r\\n\\r\\n  return { xs, ys, xRange, yRange, xScale, yScale, pos, svgWidth, svgHeight };\\r\\n};\\r\\n\\r\\n//the <any, any> is a typescript thing. It let's us define the allowed/required props (things passed into it), and the state\\r\\nexport class App extends React.Component<any, any> {\\r\\n  //init class variables\\r\\n  stopId;\\r\\n  timer;\\r\\n  xScale;\\r\\n  yScale;\\r\\n  constructor() {\\r\\n    super();\\r\\n    this.state = {\\r\\n      //only change with this.setState({var: newValue})\\r\\n      time: 0,\\r\\n      isPlaying: false,\\r\\n      data: [],\\r\\n      plotMeta: {},\\r\\n      links: [],\\r\\n      propagation: [],\\r\\n      propagationsOnScreen: []\\r\\n    };\\r\\n  }\\r\\n  componentWillMount() {\\r\\n    const savedtime = store.get(\\\"time\\\") || 0;\\r\\n    this.setState({ time: savedtime });\\r\\n\\r\\n    Promise.all([\\r\\n      fetch(\\\"../assets/data/data.json\\\").then(res => res.json()),\\r\\n      fetch(\\\"../assets/data/links.json\\\").then(res => res.json()),\\r\\n      fetch(\\\"../assets/data/propagation.json\\\").then(res => res.json())\\r\\n    ]).then(json => {\\r\\n      const data = json[0];\\r\\n      const links = json[1];\\r\\n      const propagation = json[2];\\r\\n      this.setState({ propagation });\\r\\n      this.setState({ data });\\r\\n      const { xScale, yScale, ...plotMeta } = plotSetup(\\r\\n        data,\\r\\n        svgWidth,\\r\\n        svgHeight\\r\\n      );\\r\\n      this.xScale = xScale;\\r\\n      this.yScale = yScale;\\r\\n      this.setState({ plotMeta });\\r\\n\\r\\n      const scaledLinks = links.map(link => {\\r\\n        const sx = this.xScale(link.sourcePos[0]);\\r\\n        const sy = this.yScale(link.sourcePos[1]);\\r\\n        const tx = this.xScale(link.targetPos[0]);\\r\\n        const ty = this.yScale(link.targetPos[1]);\\r\\n        return { sx, sy, tx, ty };\\r\\n      });\\r\\n      this.setState({ links: scaledLinks });\\r\\n    });\\r\\n  }\\r\\n\\r\\n  componentDidUpdate() {\\r\\n    store.set(\\\"time\\\", this.state.time);\\r\\n  }\\r\\n\\r\\n  startTimer = () => {\\r\\n    //d3.interval fires every 35ms\\r\\n    this.timer = d3.interval(elapsed => {\\r\\n      //save to this.timer so we can use this.timer.stop()\\r\\n      if (this.state.time < this.state.data[0].spikes.length)\\r\\n        this.setState({ time: this.state.time + 1 }); //increment time this way so react will rerender on change\\r\\n      this.activationLocations(this.state.propagation, this.state.time);\\r\\n    }, 15);\\r\\n  };\\r\\n\\r\\n  pauseTimer = () => {\\r\\n    this.timer.stop();\\r\\n    this.setState({ isPlaying: false });\\r\\n  };\\r\\n\\r\\n  toggleTimer = () => {\\r\\n    if (this.state.isPlaying) {\\r\\n      this.pauseTimer();\\r\\n    } else {\\r\\n      this.startTimer();\\r\\n    }\\r\\n    this.setState({ isPlaying: !this.state.isPlaying });\\r\\n  };\\r\\n  setTime = value => {\\r\\n    this.setState({ time: value });\\r\\n  };\\r\\n\\r\\n  activationLocations(propagation, time) {\\r\\n    if (!propagation || !time) return;\\r\\n    //when time is zero\\r\\n    const propagationsStarting = propagation[time] || []; //starting activations\\r\\n    const propagationsContinuing = this.state.propagationsOnScreen.filter(p => {\\r\\n          return _.get(p, 'targetActivationTime', 0) >= time;\\r\\n        })\\r\\n\\r\\n    let propagationsOnScreen = _.concat(propagationsStarting,\\r\\n      propagationsContinuing\\r\\n    );\\r\\n\\r\\n    propagationsOnScreen.forEach((p,i) => {\\r\\n      const progress = (time - p.sourceActivationTime) / p.timeDiff;\\r\\n      const pos = d3.interpolateObject(p.sourcePos, p.targetPos)(progress);\\r\\n      propagationsOnScreen[i].interpPos = [this.xScale(+pos[0]), this.yScale(+pos[1])]\\r\\n    });\\r\\n    console.log('debug', propagationsStarting, propagationsContinuing, propagationsOnScreen)\\r\\n    this.setState({ propagationsOnScreen });\\r\\n  }\\r\\n\\r\\n  render() {\\r\\n    const { svgWidth, svgHeight, pos } = this.state.plotMeta;\\r\\n    const { data, links, propagation, time, propagationsOnScreen } = this.state;\\r\\n    if (!svgWidth || !svgHeight || !pos || !propagation) return <div>loading</div>;\\r\\n    //render is a react specific function from React.Component.\\r\\n    return (\\r\\n      // the parens after return are important. also need to wrap all this html-like code in one element. a div in this case, as usual.\\r\\n      //the bellow code is jsx which is html tags that work in js. if you want to use variables, functions, or standard js from above put it in {}\\r\\n      <div>\\r\\n        <div>\\r\\n          <svg\\r\\n            width={\\\"100%\\\"}\\r\\n            height={\\\"100%\\\"}\\r\\n            style={{ maxHeight: \\\"80vh\\\" }}\\r\\n            viewBox={`0,0, ${svgWidth}, ${svgHeight}`}\\r\\n          >\\r\\n            {links.map((link, i) => {\\r\\n              const { sx, sy, tx, ty } = link;\\r\\n              return (\\r\\n                <line\\r\\n                  key={i}\\r\\n                  x1={sx}\\r\\n                  y1={sy}\\r\\n                  x2={tx}\\r\\n                  y2={ty}\\r\\n                  stroke={colors.connector}\\r\\n                  style={{ opacity: linkOpacity }}\\r\\n                />\\r\\n              );\\r\\n            })}\\r\\n            {propagationsOnScreen.map((p,i)=> {\\r\\n              return (\\r\\n                <circle\\r\\n                  key={p.id}\\r\\n                  cx={p.interpPos[0]}\\r\\n                  cy={p.interpPos[1]}\\r\\n                  r={8} // this ? : business is called a ternary operator. means if isspiking is true return 20 else return 5\\r\\n                  fill={p.sourceType === 'excites' ? colors.excitesPropagation : colors.inhibitsPropagation}\\r\\n                />\\r\\n              )\\r\\n            })}\\r\\n            {pos.map((xy, i) => {\\r\\n              //note this pos.map begings and ends with {}\\r\\n              //.map is how we loop over arrays. in this case, we return a circle for each posisiton.\\r\\n              const isSpiking = +data[i].spikes[this.state.time] === 1; //data has all the cells, each with {label, spikes, pos} fields\\r\\n              const activeColor = data[i].type === 'excites'? colors.excitesActive : colors.inhibitsActive;\\r\\n              const inActiveColor = data[i].type === 'excites'? colors.excitesInActive : colors.inhibitsInActive;\\r\\n\\r\\n              return (\\r\\n                //these parens are important in react\\r\\n                <circle\\r\\n                  key={i}\\r\\n                  cx={xy[0]}\\r\\n                  cy={xy[1]}\\r\\n                  r={isSpiking ? neuronRadius.active : neuronRadius.inActive} // this ? : business is called a ternary operator. means if isspiking is true return 20 else return 5\\r\\n                  name={data[i].label}\\r\\n                  fill={isSpiking ? activeColor : inActiveColor}\\r\\n                />\\r\\n              );\\r\\n            })}\\r\\n          </svg>\\r\\n          <Controls\\r\\n            time={this.state.time}\\r\\n            togglePlay={this.toggleTimer}\\r\\n            changeTime={this.setTime}\\r\\n            isPlaying={this.state.isPlaying}\\r\\n          />\\r\\n        </div>\\r\\n      </div>\\r\\n    );\\r\\n  }\\r\\n}\\r\\n\"]}",
headerContent: undefined,
mtime: 1502482058949,
devLibsRequired : undefined
};